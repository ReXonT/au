<?php

ini_set('display_errors', 1);

$act = $_REQUEST['act'];

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Режим OPTIONS - в котором ВРМ создаёт в схеме блок управления  *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

if($act == 'options') {
    $responce = [
        'title' => 'Разделить текст на сообщения',      // Это заголовок блока, который будет виден на схеме
        'vars' => [                     // переменные, которые можно будет настроить в блоке
            'input_text' => [
                'title' => 'Текст под разделение',   // заголовок поля
                'format' => 'textarea',
                'desc' => 'Вставьте любую переменную или полностью текст',    // описание поля, можно пару строк
            ],
        ],
        'out' => [                      // Это блоки выходов, мы задаём им номера и подписи (будут видны на схеме)
            1 => [                      // Номер 0 означает красный выход блока ВРМ, зарезервированный для случаев сбоя
                'title' => 'Результат',    // название выхода 1
            ]
        ]
    ];

    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Режим RUN - в котором ВРМ получает, обрабатывает и возвращает  *
     * полученные от схемы данные                                   *
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
} elseif($act == 'run') {              // Схема прислала данные, обрабатываем

    $target = $_REQUEST['target'];  // Пользователь, от имени которого выполняется блок
    $ums    = $_REQUEST['ums'];     // Данные об активности пользователя, массив в котором есть
    // id - номер элемента (комментария, поста, смотря о чём речь в активности)
    // from_id - UID пользователя
    // date - дата в формате timestamp
    // text - текст комментария, сообщения и т.д.
    $out    = 0;                    // Номер выхода по умолчанию. Если дальнейший код не назначит другой выход - значит что-то не так
    $options = $_REQUEST['options'];

    $input_text = $options['input_text'];

    $start_symbol_pos = 0;
    $counter = 0;
    while(1)
    {
        $message = explodeTextToMessage($input_text, $start_symbol_pos);

        $counter++; 	                    // Дабы не зациклить бесконечно + счетчик сообщений
        $strlen[] = strlen($message);       // Длины сообщений
        $result[] = $message;

        if(strlen($message) < 4000 || $counter >= 100)
            break;
        else
            $start_symbol_pos += 4000;
    }

    $out = 1;

    $responce = [
        'out' => $out,         // Обязательно должен быть номер выхода out, отличный от нуля!

        'value' => [           // Ещё можно отдать ключ value и переменные в нём будут доступны в схеме через $bN_value.ваши_ключи_массива
            'message' => $result,     // где N - порядковый номер блока в схеме
            'count' => $counter,
            'strlen' => $strlen
        ]
    ];

}
elseif($act == 'man')
{
    $responce = [
        'html' =>
            '##Описание
            ВРМ разделяет большой текст на сообщения, длиной до 4000 символов (включительно)
        
            ###Доступные переменные:
        
            **{b.{bid}.value.message}** - массив полученных сообщений
            **{b.{bid}.value.count}** - количество полученных сообщений
            **{b.{bid}.value.strlen}** - длина (количество символов) полученных сообщений
            
            ###Пример:
            После ВРМ поставьте блок "Отправить сообщение", внутрь которого вставьте переменную {b.{bid}.value.message**.0**}. Это будет первое сообщение из текста. 
            
            Затем скопируйте блок "Отправить сообщение" и там замените **0** на **1**. Получится {b.{bid}.value.message**.1**}. Это будет отправка 2 сообщения из текста.
            
            Затем скопируйте блок "Отправить сообщение" и там замените **1** на **2**. Получится {b.{bid}.value.message**.2**}. Это будет отправка 3 сообщения из текста. И тд... 
            
            Посмотреть сколько сообщений всего получилось из текста можно в переменной **{b.{bid}.value.count}**'
    ];
}

// Отдать JSON, не кодируя кириллические символы в кракозябры
echo json_encode($responce, JSON_UNESCAPED_UNICODE);



function explodeTextToMessage($text, $start = 0)
{
    if(strlen($text) >= 4000)
    {
        return substr($text, $start, $start + 4000);
    }
    else
        return $text;
}